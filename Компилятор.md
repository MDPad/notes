---
Theme: "[[C]]"
---
![[cpp.png]]

---
## Этапы работы компилятора

### Frontend

#### 1. Исходный код → Лексический анализ / Препроцессор

На этом этапе компилятор выполняет:

- **Лексический анализ**:
    
    - Исходный код преобразуется в последовательность токенов (элементарных синтаксических единиц).
    - Примеры токенов: ключевые слова (`if`, `while`), идентификаторы (`x`, `y`), символы (`+`, `=`).
- **Препроцессор**:
    
    - Обрабатываются директивы препроцессора (например, `#include`, `#define` в C/C++).
    - Производится подстановка макросов, включение заголовочных файлов и удаление комментариев.

**Результат**: последовательность токенов.

---

#### 2. Синтаксический и семантический анализ

- **Синтаксический анализ**:
    
    - Проверяется структура программы на соответствие грамматическим правилам языка.
    - Создается **синтаксическое дерево** (AST, Abstract Syntax Tree), отражающее вложенность конструкций.
- **Семантический анализ**:
    
    - Проверяется корректность типов данных, вызовов функций и использование переменных.
    - Выполняется разрешение имен (определение, где была объявлена переменная или функция).

**Результат**: абстрактное синтаксическое дерево (AST), готовое для преобразования в промежуточное представление.

---

### Optimizer + Backend

#### 3. High-level IR → Машинно-независимые оптимизации

- **High-level IR** (Intermediate Representation, промежуточное представление):
    
    - Это формат программы, абстрагированный от конкретной архитектуры процессора.
    - Примеры: трехадресный код, SSA (Static Single Assignment).
- **Машинно-независимые оптимизации**:
    
    - Эти оптимизации применяются независимо от целевой архитектуры. Основная цель — улучшение структуры программы.
    - Примеры оптимизаций:
        - **Удаление мертвого кода** (dead code elimination): удаление инструкций, не влияющих на результат.
        - **Инлайнинг функций**: подстановка тела функции вместо вызова для уменьшения накладных расходов.
        - **Устранение общих подвыражений**: вычисление повторяющихся выражений один раз.

**Результат**: оптимизированное промежуточное представление.

---

#### 4. Mid-level IR → Машинно-зависимые оптимизации (виртуальные регистры)

- **Mid-level IR**:
    
    - Более низкоуровневое промежуточное представление, ближе к целевой архитектуре.
    - Содержит операции, приближенные к машинным инструкциям, но еще использует виртуальные регистры (не привязанные к физическим).
- **Машинно-зависимые оптимизации**:
    
    - Эти оптимизации начинают учитывать особенности целевой архитектуры.
    - Примеры:
        - Упрощение доступа к памяти.
        - Разделение сложных операций на более простые, которые лучше подходят под инструкции процессора.

**Результат**: промежуточное представление с виртуальными регистрами.

---

#### 5. Low-level IR → Машинно-зависимые оптимизации (физические регистры)

- **Low-level IR**:
    
    - Представление программы максимально приближено к машинному коду.
    - Все виртуальные регистры преобразуются в физические регистры целевой архитектуры.
- **Машинно-зависимые оптимизации**:
    
    - Окончательная оптимизация с учетом конкретного процессора.
    - Примеры:
        - Распределение регистров (register allocation): эффективное использование доступных физических регистров.
        - Оптимизация инструкций для уменьшения количества тактов процессора.

**Результат**: промежуточное представление, готовое для генерации ассемблерного кода.

---

#### 6. Генерация ассемблера

- Преобразование Low-level IR в ассемблерный код, который соответствует инструкциям целевой архитектуры процессора.
- Генерируется текстовый файл с инструкциями на языке ассемблера.

**Результат**: ассемблерный код, готовый для передачи на этап ассемблерной компоновки и линковки.

---

### Дополнительные этапы

#### 7. Ассемблирование

- На этом этапе ассемблер преобразует текстовый ассемблерный код в машинные инструкции (объектный код).
- Каждая строка ассемблерного кода превращается в соответствующую машинную инструкцию для целевой архитектуры.

**Результат**: объектный файл (.obj или .o), содержащий двоичный код и метаинформацию.

---

#### 8. Линковка

- Линковщик объединяет объектные файлы и библиотеки в конечный исполняемый файл.
- Основные задачи линковщика:
    - Разрешение внешних ссылок (например, вызовы функций из других файлов).
    - Оптимизация размещения кода и данных в памяти.

**Результат**: исполняемый файл (.exe, .out или другой формат), готовый к запуску.
