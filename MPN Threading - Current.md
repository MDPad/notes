---
Theme: "[[Go - Scheduler]]"
---
https://github.com/golang/go/blob/master/src/runtime/proc.go

**M:P:N threading** — это модель, используемая в планировщике Go для управления **горутинами**. В Go Scheduler горутины распределяются между логическими процессорами и выполняются на потоках операционной системы. Это решает проблемы классических моделей (например, [[MN Threading - Example|M:N]]) и позволяет эффективно масштабировать конкурентные задачи.

---

## Основные компоненты

1. **G — Горутины:** (что исполняем)
   - Легковесные задачи, создаваемые пользователем (`go func()`).
   - Имеют динамически растущий стек (начинается с 2-4 КБ).
   - Горутины могут исчисляться миллионами.

2. **P — Логические процессоры (Processor):** (права и ресурсы для исполнения)
   - Планировочные единицы, которые управляют горутинами.
   - Каждое **P** имеет **локальную очередь горутин**, что минимизирует блокировки.
   - Количество **P** определяется переменной `GOMAXPROCS` (по умолчанию равной числу ядер CPU).

3. **M — Потоки ОС (Threads):** (где исполняем)
   - Реальные системные потоки, на которых выполняются горутины.
   - Каждый **P** привязывается к одному **M** для выполнения горутин.

---

## Механизм работы Go Scheduler

1. **Создание горутин (G):**
   - Новые горутины добавляются в локальную очередь одного из **P**.

2. **Назначение на потоки (M):**
   - Логический процессор (**P**) привязывается к системному потоку (**M**) и выполняет горутины из своей очереди.

3. **[[Work Stealing|Work-stealing:]]**
   - Если у **P** нет задач, он может "украсть" горутины из очереди другого **P**.
   - Это обеспечивает балансировку нагрузки между процессорами.

4. **Блокировка потоков (M):**
   - Если горутина блокируется (например, при вводе/выводе), **P** отвязывается от текущего **M** и переназначается на другой свободный поток.

5. **Глобальная очередь:**
   - Если горутина не может быть добавлена в локальную очередь **P**, она попадает в **глобальную очередь**.
   - Потоки обращаются к глобальной очереди только при отсутствии задач в локальных очередях.

---

![[mpn_threading.png]]

## Почему это M:P:N?

- **M** — количество **горутины (G)**, которые могут исчисляться миллионами.  
- **P** — количество **логических процессоров**, ограниченное значением `GOMAXPROCS`.  
- **N** — количество **системных потоков (M)**, на которых выполняется код.

Таким образом, Go Scheduler управляет **M горутинами** с помощью **P логических процессоров**, которые назначают задачи на **N потоков ОС**.

---

## Преимущества M:P:N модели в Go

1. **Легковесность горутин:**
   - Минимальные накладные расходы на память и переключение контекста.
   - Горутины легче потоков ОС и могут масштабироваться до миллионов.

2. **Эффективное использование CPU:**
   - Логические процессоры (**P**) равномерно распределяют горутины между ядрами CPU.
   - Использование `GOMAXPROCS` позволяет настраивать количество **P** для оптимальной производительности.

3. **Work-stealing:**
   - Позволяет сбалансировать выполнение задач между процессорами.
   - Потоки **не простаивают** из-за отсутствия задач.

4. **Обработка блокировок:**
   - Если горутина блокируется, **P** может быть переназначен на другой поток **M**, обеспечивая эффективное выполнение оставшихся задач.

---

## Сравнение с другими моделями

| **Модель**        | **Описание**                                        | **Проблемы**             | **Go Scheduler**      |
| ----------------- | --------------------------------------------------- | ------------------------ | --------------------- |
| **M:N threading** | Задачи распределяются между несколькими потоками ОС | Глобальная синхронизация | Улучшено в Go (M:P:N) |

---

## Заключение

**M:P:N threading** — это ключевая модель, используемая в **Go Scheduler**, которая позволяет:

- Эффективно **масштабировать** конкурентные задачи.  
- Использовать **work-stealing** для балансировки нагрузки.  
- Обеспечивать минимальные накладные расходы на память и управление потоками.  

Добавление **P (Processor)** между горутинами (**G**) и потоками (**M**) делает планировщик Go более эффективным, чем классический **M:N threading**.

